
import pygame as pg
import sys
from math import hypot
from itertools import cycle

from collections import namedtuple

# Note: I do believe I need to implement some kind of direct elipse
# pathing.  I make compromises when non-integer numbers of the speed

class Entity(pg.sprite.Sprite):
    def __init__(self, surface):
        pg.sprite.Sprite.__init__(self)

        # Need to define image so group.draw will draw it
        self.image = surface

        # Will get an enclosing rectangle
        self.rect = self.image.get_rect()

Coordinate = namedtuple('Coordinate', ['x', 'y'])
PatrolPoint = namedtuple('PatrolPoint', ['coord', 'wait', 'speed'])
                         
class Enemy(Entity):
    def __init__(self, surface, path):
        Entity.Sprite.__init__(self, surface)

        self.path_gen = cycle(path)
        self.target = next(self.path_gen)

        self.rect.x = path[0].coord.x
        self.rect.y = path[0].coord.y

        self.wait_time_remaining = self.path[0].wait

    def update(self, *args):
        if self.wait_time_remaining:
            self.wait_time_remaining -= 1
            return

        # Use a little bit of geometry to figure out how far we can go
        # at our given speeed.  The right triangles formed between our
        # current location and the target and how far we can go at our
        # current speed are similar.  They have the same angle measures.
        # This means that we can determine the ratio between any two similar
        # sides 
        dx = self.target.x - self.rect.x
        dy = self.target.y - self.rect.y

        dist_to_target = hypot(dx, dy)

        # This kicks in if there's a non-integer number of "speeds"
        # in the distance to travel.  FIXME: Distribute this number
        # throughout the travel distance rather than at the end
        if dist_to_target < speed:
            speed = dist_to_target

        hypot_ratio = self.target.speed / dist_to_target

        tick_dx = hypot_ratio * dx
        tick_dy = hypot_ratio * dy

        self.rect.x += tick_dx
        self.rect.y += tick_dy
